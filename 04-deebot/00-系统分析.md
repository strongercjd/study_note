# 系统分析

## 启动分析

BusyBox 的init进程会读取/etc/inittab作为启动核心配置，这是最原生的方式  

``` bash
/ # cat /etc/inittab
::sysinit:/etc/rc.sysinit
::respawn:/sbin/getty 115200 ttyFIQ0
#::respawn:/bin/sh
/ # 
```

系统初始化阶段，优先执行 rc.sysinit 脚本

``` bash
/ # cat /etc/rc.sysinit
source /etc/rc.conf
PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"
export PATH


mount -a

mkdir /dev/shm /dev/pts
mount -t tmpfs -o nodev,nosuid none /dev/shm
mount -t debugfs debugfs /sys/kernel/debug/
mount -t devpts none /dev/pts

echo "Starting UDev Daemon"
/usr/lib/udev/udevd --daemon

echo "Triggering UDev uevents"
udevadm trigger --action=add --type=subsystems
udevadm trigger --action=add --type=devices

#mdev -s
#echo /sbin/mdev > /proc/sys/kernel/hotplug

#if [[ $HOSTNAME ]]; then
#   echo $HOSTNAME > /proc/sys/kernel/hostname
#fi
sleep 0.2

hostname deboot

ifconfig lo up

# Start daemons
echo "Starting Daemons"
for daemon in ${DAEMONS}; do
  case ${daemon:0:1} in
     '!') continue;;     # Skip this daemon.
     '@') /etc/rc.d/${daemon#@} start >> /dev/null &;;
     '%') /etc/rc.d/deebot_test.sh start >> /dev/null ;;
     *)   /etc/rc.d/${daemon} start >> /dev/null ;;
  esac
done

telnetd &
sh /etc/rc.local
/ # cat /etc/rc.local
/ #
```

重要的是批量启动 DAEMONS 列表中的服务（核心）

``` bash
echo "Starting Daemons"
for daemon in ${DAEMONS}; do  # 遍历/etc/rc.conf中定义的DAEMONS变量
  case ${daemon:0:1} in
     '!') continue;;     # 跳过以!开头的服务（例如!sshd）
     '@') /etc/rc.d/${daemon#@} start >> /dev/null &;;  # @开头：后台启动
     '%') /etc/rc.d/deebot_test.sh start >> /dev/null ;; # %开头：执行deebot_test.sh
     *)   /etc/rc.d/${daemon} start >> /dev/null ;;      # 普通：前台启动（阻塞）
  esac
done
```

现在查看/etc/rc.conf

``` bash
# cat /etc/rc.conf
HOSTNAME=unknown

DAEMONS="pre_boot.sh mount_data.sh mount_userdata.sh start_watchdog.sh post_boot.sh time_sync.sh audio_service.sh wifi.sh @steward_ctl.sh ros.sh wpa_supplicant.sh rsyslog.sh @wifi_service.sh key_service.sh
medusa.sh top_service.sh channel.sh %deebot.sh airline_ctl.sh wifi_daemon.sh @dog.sh @bt-rtl8723.sh @play_boot_music.sh start_ap.sh crond.sh vsftpd.sh adbd.sh autostart.sh ota_status.sh boot_cnt.sh ubus.sh
net_manager.sh @time_zone_sync.sh @speech_recognition.sh load.sh @bt-monitor.sh @cpuReport.sh @sys_tool.sh sys_monitor.sh"
#
```

这里面有deebot.sh，表示启动时会运行 deebot.sh

还有autostart的问题,在deebot.sh中

``` bash
#!/bin/sh
#
# start/stop deebot
# version: v0.1
#
# set -x
DEEBOT_EXIT_MAKR=/tmp/deebot_exit.mark
DEEBOT_TEST_PATH=/data/autostart/deebot.sh
DEEBOT_RESUMED_LOG=/data/log/resumed.log

CONFIG_FILE_PATH="/tmp/config.bin"
if [ -f "$CONFIG_FILE_PATH" ]; then
    aivi=$(awk -F '[:,]' '/"aivi"/{gsub(/[[:space:]]/, "", $30); print $30}' /tmp/config.bin)
else
    aivi=1
fi

load()
{
    if [  -f "${DEEBOT_TEST_PATH}" ]; then
        exit
    fi

    if [ ! -f /tmp/log ]; then
        mkdir -p /tmp/log
    fi

    if [ -z "$ROS_HOSTNAME" ]
    then
        export ROS_HOSTNAME=localhost
        export ROS_MASTER_URI=http://localhost:11311
        export HOME=/data/
        #source /opt/ros/melodic/setup.sh
        export LD_LIBRARY_PATH=/opt/ros/melodic/lib:$LD_LIBRARY_PATH
    fi

    if [ "$aivi" -eq 0 ]; then
        export MALLOC_ARENA_MAX=1
    fi

    export ENABLE_UPLOAD_SLAM=1

    if [ "$aivi" -eq 1 ]; then
        export LD_PRELOAD=/usr/lib/libtcmalloc_minimal.so.4
    fi
    export MONITOR_WAIT_SEC=30
    deebot /etc/conf/dxai_node.json &> /tmp/log/log.txt &

    deebot /etc/conf/ai_collector_node.json &> /tmp/log/ai_collect_log.txt &
}

unload()
{
    touch $DEEBOT_EXIT_MAKR
    kill -SIGTERM `cat /tmp/deebot.pid`
}

case "$1" in
    start)
        load
        ;;
    stop)
        unload
        ;;
    restart)
        unload
        load
        ;;
    *)
        echo "$0 <start/stop/restart>"
        ;;
esac
```

deebot 启动命令解读

``` bash
deebot /etc/conf/dxai_node.json &> /tmp/log/log.txt &
```

* deebot 进程名
* /etc/conf/dxai_node.json 传给程序的命令行参数
* &> /tmp/log/log.txt 输出重定向（标准输出+错误输出）
* & 后台运行标识

如果希望 deebot 进程不受终端关闭影响（比如远程登录设备执行后断开连接），通常会加 nohup

``` bash
nohup deebot /etc/conf/dxai_node.json &> /tmp/log/log.txt &
```

[[04-输出重定向]]

deebot.sh的重要内容

```bash
DEEBOT_TEST_PATH=/data/autostart/deebot.sh
load()
{
    if [  -f "${DEEBOT_TEST_PATH}" ]; then
        exit
    fi
```

表示如果存在 /data/autostart/deebot.sh ，/etc/rc.d/deebot.h就不执行了

而在 /etc/rc.conf 存在 autostart.sh，也就是上电会执行autostart.sh

``` bash
#!/bin/sh
# v0.0.3 20170717
# auto start app in /data/autostart/
#


load () {
    APPS=`ls /data/autostart/*.sh `
    for apps in ${APPS};
    do
        ${apps} start
    done
}

unload () {
    APPS=`ls /data/autostart/*.sh `
    for apps in ${APPS};
    do
        ${apps} stop
    done
}

case "$1" in
      start)
            load
             ;;
       stop)
            unload
             ;;
       restart)
            unload
            load
             ;;
        *)
             echo "$0 <start/stop/restart>"
             ;;
esac
```

在 autostart.sh 中，会执行/data/autostart/下所有的.sh文件，自然包含deebot.sh
