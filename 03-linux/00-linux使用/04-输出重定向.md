# 输出重定向解读

## 示例

```bash
deebot /etc/conf/dxai_node.json &> /tmp/log/log.txt &
```

解读`&> /tmp/log/log.txt` Linux 中“合并标准输出+标准错误到同一文件”的经典写法

## Linux 标准文件描述符

Linux 中，每个进程启动后默认打开 3 个“文件描述符”（可以理解为“系统给终端/文件的编号”），用于输入/输出：

| 编号 | 名称          | 缩写 | 默认指向 | 作用                     |
|------|---------------|------|----------|--------------------------|
| 0    | 标准输入      | stdin | 键盘     | 进程读取输入（比如命令行输入） |
| 1    | 标准输出      | stdout | 终端     | 进程打印正常日志/结果     |
| 2    | 标准错误      | stderr | 终端     | 进程打印错误信息（比如报错） |

默认情况下，`stdout` 和 `stderr` 都会把内容输出到终端屏幕——而重定向的本质，就是**修改这些编号指向的目标**（从终端改成文件）。

首先写出完整的写法

```bash
1>/tmp/log/log.txt 2>&1
```

##  第一部分：`> /tmp/log/log.txt`

- 完整写法：`1> /tmp/log/log.txt`（`1` 可以省略，是 Linux 的简写规则）。
- 含义：**将“标准输出（1）”的内容重定向到 `/tmp/log/log.txt` 文件**。
  - 原本 `stdout` 要输出到终端的内容（比如 `deebot` 进程的正常日志：“AI 节点启动成功”“加载配置完成”），现在全部写入这个文件；
  - 如果文件不存在：自动创建；如果文件已存在：清空原有内容后写入（若想追加而非清空，用 `>>` 替代 `>`）。

## 第二部分：`2>&1`

这是最容易混淆的部分，逐字符解析：

- `2`：代表“标准错误（stderr）”；
- `>`：重定向符号；
- `&`：表示“引用文件描述符的当前指向”（而非普通文件）；
- `1`：代表“标准输出（stdout）”。
- 整体含义：**将“标准错误（2）”的输出，重定向到“标准输出（1）当前指向的位置”**。
  - 此时 `1` 已经被重定向到 `/tmp/log/log.txt`，所以 `2` 也会跟着指向这个文件；
  - 原本 `stderr` 要输出到终端的错误信息（比如“配置文件解析失败”“权限不足”“找不到依赖库”），现在也会写入这个 log 文件。

## 核心逻辑（执行顺序）

Linux 按**从左到右**的顺序执行重定向，所以：

1. 先把 `1`（stdout）指向 log 文件；
2. 再把 `2`（stderr）指向 `1` 的当前目标（log 文件）；
最终效果：`stdout` 和 `stderr` 的内容都写入同一个 log 文件。

## bash 进一步简写为 &>

bash 把 > file 2>&1 简写为 &> file，所以简写为

```bash
&> /tmp/log/log.txt
```
