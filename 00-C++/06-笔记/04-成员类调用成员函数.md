
# 函数回调
使用std::bind函数绑定，添加<functional>头文件

就是**函数回调**,子类调用父类的成员函数

代码入下

``` cpp
#include <iostream>
#include <functional>

class EventHandler
{
public:
    // 定义回调函数类型
    using Callback = std::function<void(const std::string &)>;

    void setCallback(Callback cb)
    {
        m_callback = cb;
    }

    void triggerEvent()
    {
        if (m_callback)
        {
            m_callback("Event occurred at 19:57");
        }
    }

private:
    Callback m_callback;
};

class Application
{
public:
    Application()
    {
        // 绑定成员函数到处理器
        m_handler.setCallback(
            std::bind(&Application::handleEvent, this, std::placeholders::_1));
    }

    void run()
    {
        m_handler.triggerEvent();
    }

private:
    void handleEvent(const std::string &msg)
    {
        std::cout << "Application handling: " << msg << std::endl;
    }

    EventHandler m_handler;
};

int main()
{
    Application app;
    app.run();
    return 0;
}
```
执行结果
``` cpp
$ ./a.out 
Application handling: Event occurred at 19:57
```

这个代码演示了C++中基于回调的事件处理机制。主要功能点如下：
1. 事件处理器类 (EventHandler)
   - 封装了一个std::function类型的回调函数
   - 提供设置回调的接口setCallback()
   - 通过triggerEvent()触发事件并执行回调

2. 应用程序类 (Application)
   - 在构造函数中使用std::bind将成员函数handleEvent绑定为事件处理器的回调
   - run()方法触发事件处理

3. 事件处理函数 (handleEvent)
执行流程
``` mermaid
graph LR
A[main函数] --> B[创建Application实例]
B --> C[调用run()]
C --> D[EventHandler触发事件]
D --> E[回调Application::handleEvent]
E --> F[输出带时间戳的事件信息]
```
当程序运行时，会输出： Application handling: Event occurred at 19:57

该代码展示了：
- 使用现代C++的回调机制（std::function + std::bind）
- 如面向对象的事件处理模式
- 类成员函数作为回调的实现方式


# 依赖注入

依赖注入在 05-架构设计/01-依赖注入DI.md 中有详细的介绍

这里就不重复了，直接上代码

> 注意：下面只是一个简单的示例，实际开发中，随着类的复杂度，可能出现循环依赖等，再具体问题具体分析，这里只是提供一个思路。

``` cpp
#include <iostream>
#include <functional>

class Application; // 前向声明

class EventHandler
{
public:
    EventHandler(const Application &app_tmp);
    void triggerEvent();
    const Application &app_; // 使用引用
};

class Application
{
public:
    Application();
    void run()
    {
        m_handler.triggerEvent();
    }

    void handleEvent(const std::string &msg) const
    { // 添加 const 修饰符
        std::cout << "Application handling: " << msg << std::endl;
    }

    EventHandler m_handler;
};

// 在Application类定义后实现EventHandler的构造函数
EventHandler::EventHandler(const Application &app_tmp) : app_(app_tmp) {}

void EventHandler::triggerEvent()
{
    app_.handleEvent("Hello, World!"); // 补充参数
}

Application::Application() : m_handler(*this) {} // 初始化m_handler

int main()
{
    Application app;
    app.run();
    return 0;
}
```

执行结果 
``` bash
$./a.out
Application handling: Hello, World!
```

