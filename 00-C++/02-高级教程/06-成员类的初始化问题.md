重要提示，在类中定义的成员类
```cpp
class SmartKitchen
{
private:
    CoffeeMaker coffeeMaker_; // 这里只是声明，没有初始化
    Toaster toaster_;         // 这里只是声明，没有初始化
};
```
只是声明，没有初始化。


示例代码

```cpp
#include <iostream>

class CoffeeMaker
{
public:
    CoffeeMaker()
    {
        std::cout << "☕ 咖啡机已自动启动" << std::endl;
    }

    void Brew()
    {
        std::cout << ">>> 正在制作美式咖啡..." << std::endl;
    }
};

class Toaster
{
public:
    Toaster()
    {
        std::cout << "🍞 面包机已准备就绪" << std::endl;
    }

    void Toast()
    {
        std::cout << ">>> 正在烘烤吐司..." << std::endl;
    }
};

class SmartKitchen
{
public:
    SmartKitchen()
    { // 构造函数中不显式初始化任何成员
        std::cout << "🏠 智能厨房初始化完成" << std::endl;
    }

    void MorningRoutine()
    {
        coffeeMaker_.Brew();
        toaster_.Toast();
    }

private:
    CoffeeMaker coffeeMaker_; // 第一个成员类
    Toaster toaster_;         // 第二个成员类
};

int main()
{
    std::cout << "===== 开始构造厨房 =====" << std::endl;
    SmartKitchen kitchen;

    std::cout << "\n===== 执行晨间流程 =====" << std::endl;
    kitchen.MorningRoutine();

    return 0;
}
```
运行结果：
```bash
$ ./a.out 
===== 开始构造厨房 =====
☕ 咖啡机已自动启动
🍞 面包机已准备就绪
🏠 智能厨房初始化完成

===== 执行晨间流程 =====
>>> 正在制作美式咖啡...
>>> 咖啡制作完成
>>> 正在烘烤吐司...
```
修改出定义的顺序
```cpp
class SmartKitchen
{
public:
    SmartKitchen()
    { // 构造函数中不显式初始化任何成员
        std::cout << "🏠 智能厨房初始化完成" << std::endl;
    }

    void MorningRoutine()
    {
        coffeeMaker_.Brew();
        toaster_.Toast();
    }

private:
    Toaster toaster_;        
    CoffeeMaker coffeeMaker_;
};
```
运行结果：
```bash
$./a.out
===== 开始构造厨房 =====
🍞 面包机已准备就绪
☕ 咖啡机已自动启动
🏠 智能厨房初始化完成

===== 执行晨间流程 =====
>>> 正在制作美式咖啡...
>>> 正在烘烤吐司...
```
可以看到，当定义的顺序不同时，构造函数的执行顺序也不同。这是因为成员变量的初始化顺序与它们在类中的声明顺序一致。
在 C++ 中，成员变量的初始化顺序是按照它们在类中声明的顺序进行的。这意味着，在构造函数中，成员变量的初始化顺序与它们在类中的声明顺序一致。


即使显性改变了成员类的初始化顺序，但是，在构造函数中，成员变量的初始化顺序与它们在类中的声明顺序一致。这意味着，在构造函数中，成员变量的初始化顺序与它们在类中的声明顺序一致。
```cpp
class SmartKitchen
{
public:
    SmartKitchen():toaster_(),coffeeMaker_()
    {
        std::cout << "🏠 智能厨房初始化完成" << std::endl;
    }

    void MorningRoutine()
    {
        coffeeMaker_.Brew();
        toaster_.Toast();
    }

private:
    CoffeeMaker coffeeMaker_;
    Toaster toaster_;
};
```
运行结果：
```bash
$./a.out
===== 开始构造厨房 =====
☕ 咖啡机已自动启动
🍞 面包机已准备就绪
🏠 智能厨房初始化完成

===== 执行晨间流程 =====
>>> 正在制作美式咖啡...
>>> 正在烘烤吐司...
```




